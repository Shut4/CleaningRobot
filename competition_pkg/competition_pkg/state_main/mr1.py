#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed")
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"ーバックメソッド#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"了）
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"
#!/usr/bin/env python3
# -*-encoding:UTF-8-*-

"""
File: foo.py
Author: Tomoaki Fujino（Kyushu Institute of Technology, Hibikino-Musashi@Home）
"""

# モジュールのインポート(ROS2関連)
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from geometry_msgs.msg import PoseStamped
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
from nav2_msgs.action._navigate_to_pose import (
    NavigateToPose_GetResult_Response,
    NavigateToPose_Feedback,
    NavigateToPose_FeedbackMessage,
)
import tf_transformations

# モジュールのインポート（YASMIN関連）
# https://github.com/uleroboticsgroup/yasmin.git
import rclpy.task
from yasmin import State
from yasmin import Blackboard


class MR1State(State):
    """FooStateクラス（Stateクラスの継承）"""

    def __init__(self, node: Node):
        """クラスの初期化メソッド

        Args:
            node (Node): Nodeクラスのオブジェクト
        """
        # 継承したStateクラスのコンストラクタをオーバーライド
        # 引数のoutcomesには，ステートが完了したときに返す可能性のある結果を文字列で指定
        super().__init__(outcomes=["succeed", "failed"])

        # Nodeオブジェクトのインスタンスを生成
        self._goal_handle: ClientGoalHandle = None
        self._result_future: NavigateToPose_GetResult_Response = None
        self._feedback: NavigateToPose_Feedback = None
        self._status: int = None

        self.node = node

        self.nav_to_pose_client = ActionClient(
            node=self.node, action_type=NavigateToPose, action_name="/navigate_to_pose"
        )

    def goToPose(self, x: float, y: float, yaw: float) -> bool:
        """指定した目的地までナビゲーションするメソッド

        Args:
            x (float): 目的地のX座標[m]
            y (float): 目的地のY座標[m]
            yaw (float): 目的地での姿勢（Yaw角）[rad]

        Returns:
            bool: 'NavigateToPoseサーバーからの返答．True（承認），False（拒否）
        """

        self.node.get_logger().debug("Waiting for 'NavigateToPose' action server")

        # NavigateToPoseサーバーと接続できるまで待機
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.node.get_logger().info("'NavigateToPose' action server not available, waiting...")

        # PoseStampedメッセージを作成し，目的地の座標と姿勢を設定
        pose = PoseStamped()

        ## 目的地の座標を設定
        pose.header.stamp = self.node.get_clock().now().to_msg()  # 現在の時間をヘッダに設定
        pose.header.frame_id = "map"  # フレームIDを'map'に設定
        pose.pose.position.x = x  # 目的地のX座標[m]
        pose.pose.position.y = y  # 目的地のY座標[m]
        pose.pose.position.z = 0.0  # 目的地のz座標[m] # 2次元平面なので0.0

        ## 目的地での姿勢を設定
        ### オイラー角からクォータニオンへの変換
        quat = tf_transformations.quaternion_from_euler(0, 0, yaw)
        pose.pose.orientation.x = quat[0]
        pose.pose.orientation.y = quat[1]
        pose.pose.orientation.z = quat[2]
        pose.pose.orientation.w = quat[3]

        # NavigateToPoseアクションのGoalメッセージを作成
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        # ログを表示
        self.node.get_logger().info(f"Navigating to goal: (x, y, yaw) = ({x}, {y}, {yaw})")

        # Goalメッセージをアクションサーバーに非同期で送信し，フィードバックメッセージ受信時に呼ぶコールバックメソッドを登録
        send_goal_future = self.nav_to_pose_client.send_goal_async(
            goal=goal_msg,  # Goalメッセージ
            feedback_callback=self._feedbackcallback,  # コールバックメソッド
        )
        # Goalメッセージの送信が完了するまで待機
        rclpy.spin_until_future_complete(self.node, send_goal_future) #修正した

        # Goalメッセージの送信結果を取得
        self._goal_handle = send_goal_future.result()

        # NavigateToPoseサーバーの承認結果を確認
        if not self._goal_handle.accepted:
            self.node.get_logger().error(f"Goal to (x, y, yaw) = ({x}, {y}, {yaw}) was rejected!")
            return False

        # 非同期で結果を取得するように設定
        self._result_future = self._goal_handle.get_result_async()
        return True

    def cancelNav(self):
        """実行中のナビゲーションをキャンセルするメソッド"""
        self.node.get_logger().info("Canceling current task.")
        if self._result_future:
            future = self._goal_handle.cancel_goal_async()
            rclpy.spin_until_future_complete(self.node, future)

    def isNavComplete(self) -> bool:
        """ナビゲーションの完了状態を確認するメソッド

        Returns:
            bool: ステータスを返す．True（キャンセル，完了），False（タイムアウト，処理中，未完了）
        """
        if not self._result_future:
            return True
        rclpy.spin_until_future_complete(self.node, self._result_future, timeout_sec=0.10)
        if self._result_future.result():
            self._status = self._result_future.result().status
            if self._status != GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().debug(f"Task with failed with status code: {self._status}")
                return True
        else:
            return False
        self.node.get_logger().debug(f"Navigation succeeded!")
        return True

    def getResult(self) -> int:
        """保留中のアクションの結果メッセージを取得するメソッド

        Returns:
            int: ステータスコードを返す．
        """
        return self._status

    def getFeedback(self) -> NavigateToPose_Feedback:
        """保留中のアクションのフィードバックメッセージを取得するメソッド

        Returns:
            NavigateToPose_Feedback: NavigateToPose_Feedbackオブジェクトを返す
        """
        return self._feedback

    def _feedbackcallback(self, msg: NavigateToPose_FeedbackMessage):
        """サーバーからのフィードバックを受信したときに呼ばれるコールバックメソッド

        Args:
            feedback_msg (NavigateToPose_FeedbackMessage): nav2_msgs/action/NavigateToPose型のFeedbackメッセージ
        """
        # フィードバックを取得
        self.node.get_logger().debug("Received action feedback message")
        self._feedback = msg.feedback


    def execute(self, blackboard: Blackboard) -> str:
        """
        FOOステートの実行メソッド

        Args:
            blackboard (Blackboard): Blackboardクラスのオブジェクト

        Returns:
            str: outcomesの文字列
        """
        # ログを表示
        self.node.get_logger().info("Executing state MR1")

        # ナビゲーション開始（初期位置に移動）
        self.goToPose(x=1.3049306316307812, y=0.171531710, yaw=0)

        # ナビゲーションは完了するまで待機
        while not self.isNavComplete():
            feedback = self.getFeedback()

            # フィードバックがまだ来ていない場合はスキップ
            if feedback is None:
                continue

            # Duration → 秒へ変換
            nav_time = feedback.navigation_time.sec + feedback.navigation_time.nanosec * 1e-9

            # 30分以上ナビゲーションし続けたらキャンセル
            if nav_time > 1800:
                self.cancelNav()

        # ナビゲーション結果を取得し，表示
        result = self.getResult()
        match result:
            case GoalStatus.STATUS_SUCCEEDED:
                self.node.get_logger().info("Nvigation succeeded!")
                return "succeed"
            case GoalStatus.STATUS_CANCELED:
                self.node.get_logger().info("Nvigation was canceled!")
                return "failed"
            case GoalStatus.STATUS_ABORTED:
                self.node.get_logger().error("Nvigation failed!")
                return "failed"
            case _:
                self.node.get_logger().error("Unknown error!")
                return "failed"

        return "succeed"